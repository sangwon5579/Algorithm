# Algorithm
---
## Branch and Bound
  
- 최적화 문제에서 **상한/하한(bound)**을 이용해 해공간을 효율적으로 탐색하는 기법이다. 문제를 여러 부분문제로 분기(branch)해 트리 구조로 보고, 현재까지 구한 최적값을 기준으로 더 이상 유망하지 않은 분기를 버려(prune) 계산량을 줄인다. 예를 들어 여행하는 세일즈맨 문제에서 현재까지 구한 최단 거리보다 더 길어질 것이 확실한 경로는 더 이상 확장하지 않는다.
  
- **정의 및 원리:** 연속적으로 해의 후보 집합을 나누어(rooted tree) 검색하며, 각 분기마다 **목적함수의 상/하한 값**을 계산하여 최적해가 될 가능성이 없는 경우 탐색하지 않는 방식이다. 모든 후보를 전수조사하되, 가지치기(bound pruning)로 불필요한 분기를 제거함으로써 효율성을 높인다.
- **설계 방법:**  
 ① 문제를 분기하여 상태공간트리의 노드를 생성한다.    
 ② 각 노드에서 **효율적인 상한/하한**을 구한다.    
 ③ 현재 최적해(best solution)가 있고 새로운 분기에서 구한 bound가 이보다 더 나쁨이 확인되면 해당 분기를 탐색하지 않는다. 보통 우선순위큐를 이용해 현재 가장 유망한 상태를 우선 처리한다.  
 예: 0-1배낭문제에서는 예상 최대 이익을 계산해 이것이 기존 최적보다 작으면 해당 분기를 버린다.
- **시간복잡도:** 본질적으로 지수적이다. 모든 분기가 최적화하여 잘르더라도 최악의 경우 여전히 전수탐색 수준이 될 수 있다. 하지만 효과적인 bound를 사용하면 일반적 완전 탐색보다 훨씬 적은 양을 탐색해 시간 성능이 좋아질 수 있다.
- **예시 문제:** NP-hard 최적화 문제에 자주 쓰인다. 대표적으로 **여행하는 세일즈맨 문제(TSP)**, **0-1 배낭 문제**, **잡 스케줄링**, **정수계획 문제(ILP)**, **8-퍼즐**, **그래프 색칠** 등이 있다. GFG 튜토리얼에 따르면 0-1 배낭(Branch & Bound), 8-퍼즐, N-Queen, TSP 등이 예시이다.
- **장점:** 완전탐색을 하면서도 유망하지 않은 경로를 배제하기 때문에 단순 백트래킹보다 실질 탐색량을 크게 줄일 수 있다. 최적해를 구할 수 있고, 메모리 허용범위 내에서 해답을 찾는다.
- **단점:** 구현이 복잡하고, 상/하한 계산(휴리스틱)이 문제마다 달라 설계가 어렵다. 또한 잘못된 bound를 쓰면 백트래킹과 큰 차이가 없으며, 여전히 계산량이 매우 클 수 있다. 최악의 경우 시간복잡도는 여전히 지수적이다.
---
