# Algorithm
---
## 1. Branch and Bound
  
- 최적화 문제에서 상한/하한(bound)을 이용해 해공간을 효율적으로 탐색하는 기법이다. 문제를 여러 부분문제로 분기(branch)해 트리 구조로 보고, 현재까지 구한 최적값을 기준으로 더 이상 유망하지 않은 분기를 버려(prune) 계산량을 줄인다. 예를 들어 여행하는 세일즈맨 문제에서 현재까지 구한 최단 거리보다 더 길어질 것이 확실한 경로는 더 이상 확장하지 않는다.
  
- **정의 및 원리:**
- 연속적으로 해의 후보 집합을 나누어(rooted tree) 검색하며, 각 분기마다 목적함수의 상/하한 값을 계산하여 최적해가 될 가능성이 없는 경우 탐색하지 않는 방식이다. 모든 후보를 전수조사하되, 가지치기(bound pruning)로 불필요한 분기를 제거함으로써 효율성을 높인다.
- **설계 방법:**
1. 문제를 분기하여 상태공간트리의 노드를 생성한다.    
2. 각 노드에서 효율적인 상한/하한을 구한다.    
3. 현재 best solution이 있고 새로운 분기에서 구한 bound가 이보다 더 나쁨이 확인되면 해당 분기를 탐색하지 않는다. 보통 우선순위큐를 이용해 현재 가장 유망한 상태를 우선 처리한다.  
 예: 0-1 KnapSack문제에서는 예상 최대 이익을 계산해 이것이 기존 최적보다 작으면 해당 분기를 버린다.
- **시간복잡도:**
- 본질적으로 지수적이다. 모든 분기가 최적화하여 자르더라도 최악의 경우 여전히 전수탐색 수준이 될 수 있다. 하지만 효과적인 bound를 사용하면 일반적 완전 탐색보다 훨씬 적은 양을 탐색해 시간 성능이 좋아질 수 있다.
- **예시 문제:**
- NP-hard 최적화 문제에 자주 쓰인다. 대표적으로 TSP, 0-1 Knapsack, job 스케줄링, 그래프 색칠 등이 있다. GFG 튜토리얼에 따르면 0-1 KS(Branch & Bound), 8-퍼즐, N-Queen, TSP 등이 예시이다.
- **장점:**
- 완전탐색을 하면서도 유망하지 않은 경로를 배제하기 때문에 단순 백트래킹보다 실질 탐색량을 크게 줄일 수 있다. 최적해를 구할 수 있고, 메모리 허용범위 내에서 해답을 찾는다.
- **단점:**
- 구현이 복잡하고, 상/하한 계산(휴리스틱)이 문제마다 달라 설계가 어렵다. 또한 잘못된 bound를 쓰면 백트래킹과 큰 차이가 없으며, 여전히 계산량이 매우 클 수 있다. 최악의 경우 시간복잡도는 여전히 지수적이다.
--- 
## 2. Doubly LinkedList  
- 각 노드가 이전 노드와 다음 노드의 포인터(링크)를 모두 가지고 있는 연결 리스트  
- **구조:**
- [ prev | data | next ]  
- prev: 이전 노드를 가리키는 포인터  
- data: 저장할 데이터  
- next: 다음 노드를 가리키는 포인터
- **장점:**
1. 양방향 이동 가능 : 이전 노드와 다음 노드 참조 가능
2. 삭제/삽입 유리 : 적절한 포인터 사용시 O(1)에 삽입/삭제 가능
3. 끝에서부터 순회 가능 : 역방향 탐색이 쉬움
- **단점:**
1. 메모리 사용 증가(prev)
2. 구현 복잡도 증가
- **주요 연산:**
- 삽입 (맨 앞/뒤) : head 또는 tail에 노드 추가	- O(1)
- 삽입 (중간) :	특정 노드 뒤에 삽입	- O(1) (노드 위치 알고 있는 경우)
- 삭제 (특정 노드)	: 노드 포인터만 수정하면 된다 -	O(1)
- 탐색 : 특정 데이터 탐색	 - O(n)
---  
